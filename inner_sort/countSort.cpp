//
// Created by 陈国威 on 2018/4/16.
//
/*
 * 计数排序，稳定性强的排序算法。时间复杂度为 O(n+k),其中n 为要排序的数的个数，
 * k 为要排序的数的组最大值。计数排序对一定量的整数排序时候速度非常快。
 * 局限性大，只限于对整数进行排序。计数排序是消耗空间复杂度来获取时间复杂度的排序法方法。
 * 其空间复杂度为 O(K), K 为要排序的最大值
 * */

// 跟字符串的低位优先的字符串排序类似

/*
 * A是一个输入数组
 * B是一个排序好的数组
 * k是数组中最大值
 * n是数组的个数
 * */
void count_sort(int *A, int *B, int k, int n)
{
  int *C = new int[k];

  for (int i = 0; i < k; ++i)
    {
      C[i] = 0; // 初始化C数组
    }

  // 统计 i 的次数
  for (int j = 0; j < n; ++j)
    {
      C[A[j]] = C[A[j]] + 1;  //
    }

  // 对所有的计数累加
  for (int l = 1; l < k; ++l)
    {
      C[l] = C[l] +  C[l -1];
    }

  // 逆向遍历源数组，根据计数数组中对应的值填充到先的数组中
  for (int i = n - 1; i >= 0; --i)
    {
      B[C[A[i]]] = A[i];
      C[A[i]] = C[A[i]] - 1;
    }

  delete C;
}


//测试
int main(void)
{

  return 0;
}

